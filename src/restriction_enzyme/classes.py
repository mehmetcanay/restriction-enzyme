#!/usr/bin/env python

from typing import Any
from restriction_enzyme.restriction_dictionary import rest_dict
import pandas as pd

complementary_nucleotides: dict[str, str] = {"A": "T", "T": "A", "C": "G", "G": "C"}


class RestrictionEnzyme:
    def __init__(self, rest_dict) -> None:
        self.__recognition_site: str = rest_dict["site"]
        self.__cleavage_position: tuple[int, int] = (
            rest_dict["fst5"],
            rest_dict["fst3"],
        )
        self.__over_hanging_sequence: str = rest_dict["ovhgseq"]

    @property
    def recognition_site(self) -> str:
        return self.__recognition_site

    @recognition_site.setter
    def recognition_site(self, value: str) -> None:
        self.__recognition_site = value

    @property
    def cleavage_position(self) -> tuple[int, int]:
        return self.__cleavage_position

    @cleavage_position.setter
    def cleavage_position(self, value: tuple[int, int]) -> None:
        self.__cleavage_position = value

    @property
    def over_hanging_sequence(self) -> str:
        return self.__over_hanging_sequence

    @over_hanging_sequence.setter
    def over_hanging_sequence(self, value: str) -> None:
        self.__over_hanging_sequence = value

    def is_palindromic(self) -> bool:
        """
        Checks if the given restriction enzyme is palindromic,
        returns a boolean accordingly.

        Returns:
            bool: Is the restriction enzyme palindromic
        """

        # A string to be build as the complementary sequence of the recognition site
        complementary_sequence: str = ""

        # Getting the recognitions site
        recog_site: str = self.recognition_site

        # Iterate over the nucleotides of the recognition site in
        # reverse, and build the complementary nucleotide sequence
        for nucleotide in reversed(recog_site):
            complementary_sequence += complementary_nucleotides[nucleotide]

        # If they are identical, the restriction enzyme is
        # palindromic. Hence, return True, else False.
        if recog_site == complementary_sequence:
            return True

        else:
            return False

    def is_sticky(self) -> bool:
        """
        Checks if the restriction enzyme is creating sticky ends

        Returns:
            bool: Is the restriction enzyme creating sticky ends
        """

        # Get the over hanging sequence
        over_hang: str = self.over_hanging_sequence

        # If the overhanging sequence is not empty,
        # the restriction enzyme creates sticky ends.
        if over_hang:
            return True

        else:
            return False

    def find_all_occurrences(self, string: str) -> list[int]:
        """Finds indices of all occurences of a substring in a given string.

        Args:
            string (str): A string to search for a substring in
            substring (str): A substring to be searched in string

        Returns:
            list_ (list[int]): List of indices of occurences of the given substring in the given string
        """

        # Initialize list and start to hold list of indices and starting position, respectively.
        list_: list[int] = []
        start: int = 0
        substring: str = self.recognition_site

        while start < len(string):
            # Look for the substring in the string
            start = string.find(substring, start)

            # If the end is reached break the loop
            if start == -1:
                break

            # Append the found index to the list
            list_.append(start)

            # Increment start by 1
            start += 1

        # Return the list
        return list_

    def cleave_dna(self, dna) -> list[dict[str, bool | str | list[str]]]:
        """
        Finds all the fragments that will generated by the restriction enzyme
        with given dna instance. Returns the information alongside with
        information on stickyness of the fragments and the over hanging sequence

        Args:
            dna (Dna): An instance of the Dna class

        Returns:
            info_list (list[dict[str, bool | str | list[str]]]): Comprehensive
            information on the restriction enzyme with given Dna instance
        """

        # Getting the sequence from Dna instance
        sequence: str = dna.sequence

        # Getting all the indices of occurence of recognition site in the sequence
        recog_sites: list[int] = self.find_all_occurrences(sequence)

        # Initializing the fragments list
        fragments: list[str] = []

        # Only 5' to 3' prime is considered
        cleavage: int = self.cleavage_position[0]

        # Initializing the start
        start: int = 0

        # Finding all the fragments generated by the restriction enzyme
        for index in recog_sites:
            fragments.append(sequence[start : index + cleavage])
            start = index + cleavage

        # To get the last fragment
        fragments.append(sequence[start:])

        # Accounting for the circular structure of the plasmid
        start_point: str = fragments[0][::-1]
        end_point: str = fragments[-1][::-1]

        del fragments[0]
        del fragments[-1]

        fragments.append(start_point + end_point)

        info_list: list[dict[str, bool | str | list[str]]] = [
            {
                "sticky": self.is_sticky(),
                "over_hanging_sequence": self.over_hanging_sequence,
                "fragments": fragments,
            }
        ]

        return info_list


class Fasta:
    def __init__(self, path_to_file: str) -> None:
        self.__sequences: list[Dna] = self.read(path_to_file)

    @property
    def sequences(self):
        return self.__sequences

    @sequences.setter
    def sequences(self, value):
        self.__sequences = value

    def read(self, path_to_file: str):
        # Initialize variables to store sequence ID and sequence data
        identifier: str = ""
        seq: str = ""
        sequences: list[Dna] = []

        # Read the FASTA file line by line
        with open(path_to_file, "r") as file:
            for line in file:
                # Remove newline characters
                line: str = line.strip()

                # Check if the line is empty or a comment line (starts with ">")
                if line.startswith(">"):
                    # If a sequence is already being processed,
                    # append the instance of Dna to the sequences list
                    if identifier and seq:
                        sequences.append(Dna(seq, identifier))

                    # Extract the sequence ID from the line
                    identifier = line[1:]
                    # Reset sequence data for the new sequence
                    seq = ""
                else:
                    # Concatenate sequence data if the line contains sequence information
                    seq += line

        # Print or process the last sequence in the FASTA file
        if identifier and seq:
            sequences.append(Dna(seq, identifier))

        return sequences


class Dna:
    def __init__(self, sequence: str, identifier: str) -> None:
        self.__sequence: str = sequence
        self.__identifier: str = identifier

    @property
    def sequence(self) -> str:
        return self.__sequence

    @property
    def identifier(self) -> str:
        return self.__identifier


# Filtering the rest_dict
def filter_rest_dict(rest_dict: dict[str, Any]) -> dict[str, Any]:
    """
    Filters the restriction enzyme dictionary and returns a cleaner dictionary

    Args:
        rest_dict (dict[str, Any]): Unfiltered restriction enzyme dictionary

    Returns:
        restriction_df (pd.DataFrame): Filtered restriction enzyme dataframe
    """

    filtered_rest_dict: dict[str, Any] = {}

    for enzyme in rest_dict:
        # Create an instance of RestrictionEnzyme
        rest_enzyme = RestrictionEnzyme(rest_dict[enzyme])

        # Get the set of nucleotides from the recognition site
        nucleotides = set(rest_enzyme.recognition_site)

        # Filter the recognition sites containing nucleotides other than
        # deoxyribonucleotides
        if nucleotides == set(["A", "T", "C", "G"]):
            # Filter out the non-palindromic enzymes
            if rest_enzyme.is_palindromic():
                # Filter out the enzymes with no cleaveage position
                if rest_enzyme.cleavage_position[0] is not None:
                    # Filter out the enzymes that cuts outside of the recognition site
                    if rest_enzyme.cleavage_position[0] < len(
                        rest_enzyme.recognition_site
                    ):
                        filtered_rest_dict[enzyme] = rest_dict[enzyme]

    return filtered_rest_dict


# Filtering the dictionary of enzymes
rest_dict: dict[str, Any] = filter_rest_dict(rest_dict)


def site_finder(file_path: str, enzyme_dict: dict[str, Any]) -> pd.DataFrame:
    fasta = Fasta(file_path)
    dnas: list[Dna] = fasta.sequences
    df: pd.DataFrame = pd.DataFrame()

    for enzyme in enzyme_dict:
        rest_enzyme = RestrictionEnzyme(enzyme_dict[enzyme])
        for dna in dnas:
            sequence: str = dna.sequence
            indices: list[int] = rest_enzyme.find_all_occurrences(sequence)

            temp = pd.DataFrame(
                {
                    "name": enzyme,
                    "position": indices,
                    "ovhseq": rest_enzyme.over_hanging_sequence,
                    "sticky": rest_enzyme.is_sticky(),
                }
            )

            df = pd.concat([df, temp])

    df.reset_index(drop=True, inplace=True)

    return df